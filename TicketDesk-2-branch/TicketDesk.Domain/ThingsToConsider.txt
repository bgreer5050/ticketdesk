Application Settings:
	The exports and such in the application settings service are a bit
	of a mess. Some are properties, others are methods (and for good
	reason). Need to standardize these all as methods.

	Also need to re-evaluate which of these need to be MEF exports now
	that they belong nativly to the domain. Most of them are probably
	best left as exports, but some of them may be better if the 
	importing class directly accesses them rather than relying on MEF.
	Which way is best depends mostly on if the importing mechanism can
	get at the application settings without needing to instantiate the
	security or full settings service.



Search:

	Investigate the advanced query syntax for lucene, and why it isn't
	working with the query object I'm using currently.

	See about updating the existing index more dynamically instead of 
	completely re-building it. Update existing tickets that don't have
	new changes; build and save open tickets first then do a second 
	pass to handle the history tickets.

	Add a search limit to application settings. Currently it is 
	hard-coded.

Controller coupling with views:

	Several features in views are using extension methods that require 
	access to a controller. The general reason is because the controller
	has access to instances of the back-end services like the sercurity
	service. This coupling is ugly. In addition, it prevents the use of
	several partials from other views that are tied to other controllers
	than the one the partial was originaly built for (for example, the 
	email templates can't render the ticketeditor partials as-is because
	those partials expect to have access to a TicketEditorController, not
	the EmailTemplateController). 
	
	In keeping with good MVC patterns, we need to de-couple the views and
	controllers. For the most part, the stuff the views are invoking 
	themselves should be supplied via a viewmodel, rather than the 
	view having to invoke functionality to fetch the data itself. 
	Otherwise, there should be a standard library of helpers that the views 
	can invoke that are not tied to controller instances (perhapse they 
	instantiate the necessary service instances themselves or whatever). 

MvcContrib usage in Domain:

	The goal was to avoid web specific functionality in the domain project 
	keeping it free to back-end for Silverlight, WebForms, or web-service
	front-ends too.
	 
	The paging stuff now uses paging classes from MvcContrib. The reference
	to MvcContrib in this particular isolated case is probably fine, even if the
	domain class lib were to be used in a windows client or silverlight 
	environment, but this does come dangerously close to coupling the back-end
	with a specific front-end expecatation, and makes it very easy for future 
	development to leverage functionality from MvcContrib that IS coupled to 
	an MVC environment. 

	Need to eliminate the use of MvcContrib if possible and let the front-end
	handle wrapping queries in pagable implentations if/when it needs it that
	way. 
	
MEF Extensible Services Implemenation:

	Security and the EmailHandler are setup as selectable MEF exports. The 
	back-end can have multiple classes that can satisfy the imports, but the
	system will leverage only the one type that is specified in the front-end.
	This makes the system partially pluggable via MEF.

	The idea here would be to move the built-in modules into seperate class-libs
	as well and document how the extensibility can be used by other developers. 
	This may also mean the domain project's interfaces (some or all) would need 
	to be moved into a new class library as well so that custom modules would be
	able to inherit the interfaces, without having to reference the entire domain
	class lib directly.

DataAnnotations for Friendly Column Names in List Output:

	DataAnnotations allows you to flag fields with friendly names at 
	the UI. See about replacing the code for the list settings and 
	such that uses string manipulation and replace with one that 
	leverages the names from DataAnnotations. This will be affected
	by the plans for full MVVM support in the front end though.

MVVM:

	The application REALLY needs to go MVVM for the front end. The main reason for
	this is to clean up the need for views to reference controllers and the need
	for non-model ViewData items. This will be essential for clean usage of 
	the Razor view engine as well.
	
	This would allow us also move the data annotations from the back-end
	to the front-end; putting the annotations and that part of the validation
	on the viewmodels instead of the EF entities. Not that validation isn't
	good in EF entities too, but EF doesn't play well with dataannotations
	and so data annotations seems like a duplication of the EF data defintion 
	attributes. 
	
	When doing this, don't forget to see about moving some of the 
	custom validation mechanisms out of the Ticket Service as well. These aren't
	based on dataannotations, but their function may fit better in the front end
	anyway. 
	
Security:

	1) Current User Name property - this seems weak-sauce; sort of 
	    a global variable type usage. Other than this, 
		and the GetUserDisplayName() method of the security service
		the TicketService could probably be decoupled from security
		entirely. See about having the caller supply these values.
		
	2) The Security Service really isn't handling authentication 
	    and identity stuff. This is being left up to the hosting
		web app (and for good reason). Still, should consider using
		the "Client Application Services" feature to bring in the
		full membership, profile, roles systems... or see about 
		refactoring this completely. This may also overlap with 
		potential considerations for OpenID and such.

	3) The profile service sucks. Plain and simple. Replace this
	    with a hand-rolled (non-provider) based system. Handle
		List settings and such directly in the DB and via EF. 

	4) Move membership update operations into the service in the 
	   same way we moved the adding/removing of roles. 

Validation: 

	The rules based Validation in TicketSerivce with methods like 
		ValidateTicketDetailFields() are probably obsolete now that 
		we're using model validation via data annotations. We probably
		do still need to check with data annotations in the service 
		before we commit the records just in case someone is actually
		trying a hack or what not. 

		This is impacted heavily by the architectual decisions related
		to MVVM. 

UI:

	By Rapid clicking activity buttons, it is possible to queue multiple 
	requests for the same action (like double assigning). Need to have 
	the domain model reject activity changes like that when they don't 
	result in a difference (like when assigning to the currently 
	assigned user, or setting the priority to the same as the current
	priority). Should also see about blocking requests on the client
	so only one concurrent ajax request can be in progress at a time.


Editors

	Now that WMD and Markdown are both supported, we need to wrap the
	editor junk up into runtime swappable components of some sort. 
	Ideally, we'd use MEF to support a plug-in style editor component
	and have the runtime choose the correct plug-in based on a merge
	of user and system preferences.

	Role Editor Modes:

		Partial support is in place for application wide allowed text editor
		modes on a per-role basis. By partial support, I mean that there is
		a repository method that is implemented that can read the settings 
		from the settings table (the settings themselves are NOT part of
		the current default values). 

		This system needs to be fleshed out. The general idea is that the
		admin can choose which roles are allowed which choices of editor
		and what the default editor for each role should be. Users can then
		select (in their user preferences) which of the available editors 
		they will prefer.

		This also requires that the front-end support the various editors.


Authorization:

	The authorization filter needs to detect if the request is an ajax request
	and do something different so the login doesn't show up in a partial view
	response.