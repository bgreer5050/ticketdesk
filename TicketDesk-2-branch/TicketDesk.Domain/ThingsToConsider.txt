Controller coupling with views:

	Several features in views are using extension methods that require 
	access to a controller. The general reason is because the controller
	has access to instances of the back-end services like the sercurity
	service. This coupling is ugly. In addition, it prevents the use of
	several partials from other views that are tied to other controllers
	than the one the partial was originaly built for (for example, the 
	email templates can't render the ticketeditor partials as-is because
	those partials expect to have access to a TicketEditorController, not
	the EmailTemplateController). 
	
	In keeping with good MVC patterns, we need to de-couple the views and
	controllers. For the most part, the stuff the views are invoking 
	themselves should be supplied via a viewmodel, rather than the 
	view having to invoke functionality to fetch the data itself. 
	Otherwise, there should be a standard library of helpers that the views 
	can invoke that are not tied to controller instances (perhapse they 
	instantiate the necessary service instances themselves or whatever). 

MvcContrib usage in Domain:

	The goal was to avoid web specific functionality in the domain project 
	keeping it free to back-end for Silverlight, WebForms, or web-service
	front-ends too.
	 
	The paging stuff now uses paging classes from MvcContrib. The reference
	to MvcContrib in this particular isolated case is probably fine, even if the
	domain class lib were to be used in a windows client or silverlight 
	environment, but this does come dangerously close to coupling the back-end
	with a specific front-end expecatation, and makes it very easy for future 
	development to leverage functionality from MvcContrib that IS coupled to 
	an MVC environment. 

	Need to eliminate the use of MvcContrib if possible and let the front-end
	handle wrapping queries in pagable implentations if/when it needs it that
	way. 
	
MEF Extensible Services Implemenation:

	Security and the EmailHandler are setup as selectable MEF exports. The 
	back-end can have multiple classes that can satisfy the imports, but the
	system will leverage only the one type that is specified in the front-end.
	This makes the system partially pluggable via MEF.

	The idea here would be to move the built-in modules into seperate class-libs
	as well and document how the extensibility can be used by other developers. 
	This may also mean the domain project's interfaces (some or all) would need 
	to be moved into a new class library as well so that custom modules would be
	able to inherit the interfaces, without having to reference the entire domain
	class lib directly.

DataAnnotations for Friendly Names in List Output:

	DataAnnotations allows you to flag fields with friendly names at 
	the UI. See about replacing the code for the list settings and 
	such that uses string manipulation and replace with one that 
	leverages the names from DataAnnotations.
	
Security:

	1) Current User Name property - this seems weak-sauce; sort of 
	    a global variable type usage. Other than this, 
		and the GetUserDisplayName() method of the security service
		the TicketService could probably be decoupled from security
		entirely. See about having the caller supply these values.
		
	2) The Security Service really isn't handling authentication 
	    and identity stuff. This is being left up to the hosting
		web app (and for good reason). Still, should consider using
		the "Client Application Services" feature to bring in the
		full membership, profile, roles systems... or see about 
		refactoring this completely. This may also overlap with 
		potential considerations for OpenID and such.

	3) The profile service sucks. Plain and simple. Replace this
	    with a hand-rolled (non-provider) based system. Handle
		List settings and such directly in the DB and via EF. 

Validation: 

	The rules based Validation in TicketSerivce with methods like 
		ValidateTicketDetailFields() are probably obsolete now that 
		we're using model validation via data annotations. We probably
		do still need to check with data annotations in the service 
		before we commit the records just in case someone is actually
		trying a hack or what not. 

UI:

	By Rapid clicking activity buttons, it is possible to queue multiple 
	requests for the same action (like double assigning). Need to have 
	the domain model reject activity changes like that when they don't 
	result in a difference (like when assigning to the currently 
	assigned user, or setting the priority to the same as the current
	priority). Should also see about blocking requests on the client
	so only one concurrent ajax request can be in progress at a time.


Editors

	Now that WMD and Markdown are both supported, we need to wrap the
	editor junk up into runtime swappable components of some sort. 
	Ideally, we'd use MEF to support a plug-in style editor component
	and have the runtime choose the correct plug-in based on a merge
	of user and system preferences.
	
 AD Repository

	The AD repository still needs major re-factoring for performance.
	Initial beta testing shows that this system, though comparable to 
	1.x, is still too slow and has problems when AD is unavailable. 

	The ideal solution would be to cache the AD values and information 
	in SQL; an automated timer driven mechanism would periodically 
	rebuild/refresh the SQL cache. The actual repository that is 
	feeding the user requests would use only the cache stored in SQL. 
	This could increase staleness for the AD data, but realistically 
	that data isn't that essential and changes very infrequently 
	(if ever). 
	
	This kind of local-store would also prevent the application from 
	blowing-up when and if AD becomes unavailable for a while.

	The tricky part would be ensuring that the SQL cache mechanism knows 
	about EVERY user that it needs to refresh on, without necessarily having
	to table-scan every table that could contain user name looking for all 
	possible distinct values before it can do a lookup in AD. 

Authorization:

	The authorization filter needs to detect if the request is an ajax request
	and do something different so the login doesn't show up in a partial view
	response.